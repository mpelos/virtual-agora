"""Report export functionality for Virtual Agora.

This module provides functionality to export reports in various formats
including combined Markdown, HTML, and archives.
"""

import logging
import shutil
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from datetime import datetime
import re

from ..utils.logging import get_logger

logger = get_logger(__name__)


class ReportExporter:
    """Export reports in various formats."""

    # HTML template for reports
    HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            background-color: white;
            padding: 40px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }}
        h1 {{
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }}
        h2 {{
            color: #34495e;
            margin-top: 30px;
        }}
        h3 {{
            color: #7f8c8d;
        }}
        pre {{
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }}
        code {{
            background-color: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }}
        blockquote {{
            border-left: 4px solid #3498db;
            padding-left: 20px;
            margin-left: 0;
            color: #666;
            font-style: italic;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }}
        table, th, td {{
            border: 1px solid #ddd;
        }}
        th, td {{
            padding: 12px;
            text-align: left;
        }}
        th {{
            background-color: #f2f2f2;
        }}
        .metadata {{
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }}
        .footer {{
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }}
        @media print {{
            body {{
                background-color: white;
            }}
            .container {{
                box-shadow: none;
                padding: 0;
            }}
        }}
    </style>
</head>
<body>
    <div class="container">
        {content}
        <div class="footer">
            Generated by Virtual Agora on {timestamp}
        </div>
    </div>
</body>
</html>"""

    def __init__(self):
        """Initialize ReportExporter."""
        self.supported_formats = ["markdown", "html", "archive", "combined"]

    def export_report(
        self,
        report_dir: Path,
        output_path: Path,
        format: str = "combined",
        include_metadata: bool = True,
        include_assets: bool = True,
    ) -> Path:
        """Export a report in the specified format.

        Args:
            report_dir: Source report directory.
            output_path: Output path for the export.
            format: Export format (markdown, html, archive, combined).
            include_metadata: Whether to include metadata files.
            include_assets: Whether to include additional assets.

        Returns:
            Path to the exported file.
        """
        if format not in self.supported_formats:
            raise ValueError(f"Unsupported format: {format}")

        try:
            if format == "markdown":
                return self._export_markdown(report_dir, output_path, include_metadata)
            elif format == "html":
                return self._export_html(report_dir, output_path, include_metadata)
            elif format == "archive":
                return self._export_archive(report_dir, output_path, include_assets)
            elif format == "combined":
                return self._export_combined(report_dir, output_path)

        except Exception as e:
            logger.error(f"Error exporting report: {e}")
            raise

    def _export_markdown(
        self,
        report_dir: Path,
        output_path: Path,
        include_metadata: bool = True,
    ) -> Path:
        """Export as a single combined Markdown file.

        Args:
            report_dir: Source report directory.
            output_path: Output file path.
            include_metadata: Whether to include metadata.

        Returns:
            Path to the exported file.
        """
        # Ensure .md extension
        if output_path.suffix != ".md":
            output_path = output_path.with_suffix(".md")

        # Collect all Markdown files in order
        md_files = sorted(
            [f for f in report_dir.glob("*.md") if f.name != "README.md"],
            key=lambda x: x.name,
        )

        combined_content = []

        # Add metadata header if requested
        if include_metadata:
            metadata_path = report_dir / "report_metadata.json"
            if metadata_path.exists():
                combined_content.extend(
                    [
                        "---",
                        "title: Virtual Agora Report",
                        f"generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                        f"source: {report_dir.name}",
                        "---",
                        "",
                    ]
                )

        # Combine all markdown files
        for md_file in md_files:
            content = md_file.read_text(encoding="utf-8")

            # Skip table of contents in combined file
            if md_file.name == "00_Table_of_Contents.md":
                continue

            # Add file separator
            if combined_content:
                combined_content.extend(
                    [
                        "",
                        "---",
                        "",
                    ]
                )

            combined_content.append(content)

        # Write combined file
        output_path.write_text("\n".join(combined_content), encoding="utf-8")

        logger.info(f"Exported combined Markdown to {output_path}")
        return output_path

    def _export_html(
        self,
        report_dir: Path,
        output_path: Path,
        include_metadata: bool = True,
    ) -> Path:
        """Export as an HTML file.

        Args:
            report_dir: Source report directory.
            output_path: Output file path.
            include_metadata: Whether to include metadata.

        Returns:
            Path to the exported file.
        """
        # Ensure .html extension
        if output_path.suffix != ".html":
            output_path = output_path.with_suffix(".html")

        # First create combined markdown
        temp_md = tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False)
        temp_md_path = Path(temp_md.name)
        temp_md.close()

        try:
            # Export to temporary markdown
            self._export_markdown(report_dir, temp_md_path, include_metadata)

            # Convert markdown to HTML
            md_content = temp_md_path.read_text(encoding="utf-8")
            html_content = self._markdown_to_html(md_content)

            # Get title from first heading
            title_match = re.search(r"^#\s+(.+)$", md_content, re.MULTILINE)
            title = title_match.group(1) if title_match else "Virtual Agora Report"

            # Apply template
            final_html = self.HTML_TEMPLATE.format(
                title=title,
                content=html_content,
                timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            )

            # Write HTML file
            output_path.write_text(final_html, encoding="utf-8")

            logger.info(f"Exported HTML to {output_path}")
            return output_path

        finally:
            # Clean up temporary file
            temp_md_path.unlink()

    def _markdown_to_html(self, markdown_content: str) -> str:
        """Convert Markdown to HTML (basic implementation).

        Args:
            markdown_content: Markdown content.

        Returns:
            HTML content.
        """
        html = markdown_content

        # Convert headers
        for i in range(6, 0, -1):
            html = re.sub(
                f"^{'#' * i}\\s+(.+)$", f"<h{i}>\\1</h{i}>", html, flags=re.MULTILINE
            )

        # Convert bold
        html = re.sub(r"\*\*([^*]+)\*\*", r"<strong>\1</strong>", html)

        # Convert italic
        html = re.sub(r"\*([^*]+)\*", r"<em>\1</em>", html)

        # Convert code blocks
        html = re.sub(
            r"```([^`]+)```", r"<pre><code>\1</code></pre>", html, flags=re.DOTALL
        )

        # Convert inline code
        html = re.sub(r"`([^`]+)`", r"<code>\1</code>", html)

        # Convert lists
        lines = html.split("\n")
        in_list = False
        processed_lines = []

        for line in lines:
            # Unordered list
            if re.match(r"^[-*+]\s+", line):
                if not in_list:
                    processed_lines.append("<ul>")
                    in_list = True
                processed_lines.append(re.sub(r"^[-*+]\s+(.+)$", r"<li>\1</li>", line))
            # Ordered list
            elif re.match(r"^\d+\.\s+", line):
                if not in_list:
                    processed_lines.append("<ol>")
                    in_list = True
                processed_lines.append(re.sub(r"^\d+\.\s+(.+)$", r"<li>\1</li>", line))
            else:
                if in_list:
                    tag = "</ul>" if processed_lines[-2].startswith("<ul>") else "</ol>"
                    processed_lines.append(tag)
                    in_list = False
                processed_lines.append(line)

        # Close any open list
        if in_list:
            tag = "</ul>" if "<ul>" in processed_lines else "</ol>"
            processed_lines.append(tag)

        html = "\n".join(processed_lines)

        # Convert paragraphs
        html = re.sub(r"\n\n+", "</p>\n<p>", html)
        html = f"<p>{html}</p>"

        # Clean up empty paragraphs
        html = re.sub(r"<p>\s*</p>", "", html)
        html = re.sub(r"<p>(<h\d>)", r"\1", html)
        html = re.sub(r"(</h\d>)</p>", r"\1", html)

        return html

    def _export_archive(
        self,
        report_dir: Path,
        output_path: Path,
        include_assets: bool = True,
    ) -> Path:
        """Export as an archive (ZIP).

        Args:
            report_dir: Source report directory.
            output_path: Output file path.
            include_assets: Whether to include all assets.

        Returns:
            Path to the exported archive.
        """
        # Remove extension as shutil.make_archive adds it
        if output_path.suffix == ".zip":
            output_path = output_path.with_suffix("")

        # Create archive
        archive_path = shutil.make_archive(
            base_name=str(output_path),
            format="zip",
            root_dir=report_dir.parent,
            base_dir=report_dir.name,
        )

        logger.info(f"Exported archive to {archive_path}")
        return Path(archive_path)

    def _export_combined(
        self,
        report_dir: Path,
        output_dir: Path,
    ) -> Dict[str, Path]:
        """Export in multiple formats.

        Args:
            report_dir: Source report directory.
            output_dir: Output directory.

        Returns:
            Dictionary mapping format to output path.
        """
        output_dir.mkdir(parents=True, exist_ok=True)

        results = {}

        # Export all formats
        base_name = report_dir.name

        # Markdown
        md_path = output_dir / f"{base_name}.md"
        results["markdown"] = self._export_markdown(report_dir, md_path)

        # HTML
        html_path = output_dir / f"{base_name}.html"
        results["html"] = self._export_html(report_dir, html_path)

        # Archive
        zip_path = output_dir / f"{base_name}.zip"
        results["archive"] = self._export_archive(report_dir, zip_path)

        logger.info(f"Exported combined formats to {output_dir}")
        return results

    def export_selective(
        self,
        report_dir: Path,
        output_path: Path,
        sections: List[str],
        format: str = "markdown",
    ) -> Path:
        """Export only selected sections.

        Args:
            report_dir: Source report directory.
            output_path: Output file path.
            sections: List of section titles to include.
            format: Export format.

        Returns:
            Path to the exported file.
        """
        # Create temporary directory with selected files
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)

            # Copy selected section files
            for md_file in report_dir.glob("*.md"):
                content = md_file.read_text(encoding="utf-8")

                # Check if this file contains any requested sections
                for section in sections:
                    if section in content:
                        shutil.copy(md_file, temp_path / md_file.name)
                        break

            # Also copy metadata files
            for meta_file in ["report_metadata.json", "manifest.json", "README.md"]:
                src = report_dir / meta_file
                if src.exists():
                    shutil.copy(src, temp_path / meta_file)

            # Export from temporary directory
            return self.export_report(temp_path, output_path, format)

    def create_shareable_link(self, report_path: Path) -> str:
        """Create a shareable link for the report (placeholder).

        Args:
            report_path: Path to the report file.

        Returns:
            Shareable link or instruction.
        """
        # This is a placeholder - in a real implementation,
        # this would upload to a cloud service
        return (
            f"To share this report, upload '{report_path.name}' to your "
            "preferred file sharing service (e.g., Google Drive, Dropbox)."
        )
